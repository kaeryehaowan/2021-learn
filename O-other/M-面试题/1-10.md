## 1. 实现一个 compose 函数
```js
// 用法如下:
function fn1(x) {
  return x + 1;
}
function fn2(x) {
  return x + 2;
}
function fn3(x) {
  return x + 3;
}
function fn4(x) {
  return x + 4;
}
const a = compose(fn1, fn2, fn3, fn4);
console.log(a(1)); // 1+4+3+2+1=11
```

## 2.1 settimeout 模拟实现 setinterval(带清除定时器的版本)
```js
let a=mySettimeout(()=>{
  console.log(111);
},1000)
```
## 2.2 setinterval 模拟实现 settimeout(带清除定时器的版本)
```JS
mySetTimeout(()=>{
  console.log(1);
},1000)
```

## 3. 实现一个发布订阅模式拥有 on emit once off 方法
```JS
const event = new EventEmitter();

const handle = (...rest) => {
  console.log(rest);
};

event.on("click", handle);

event.emit("click", 1, 2, 3, 4);

event.off("click", handle);

event.emit("click", 1, 2);

event.once("dbClick", () => {
  console.log(123456);
});
event.emit("dbClick");
event.emit("dbClick");
```

## 4. 数组去重


## 5. 实现一个方法使多维数组变成一维数组
```JS
console.log(flatter([1, 2, [1, [2, 3, [4, 5, [6]]]]]));
```

## 6. 实现一个你认为不错的 js 继承方式
```JS
let child = new Children("111");
console.log(child.name);
child.say();
child.play();
```

## 7. JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个
```js
 addTask(1000,"1");
 addTask(500,"2");
 addTask(300,"3");
 addTask(400,"4");
//  的输出顺序是：2 3 1 4

//  整个的完整执行流程：
// 一开始1、2两个任务开始执行
// 500ms时，2任务执行完毕，输出2，任务3开始执行
// 800ms时，3任务执行完毕，输出3，任务4开始执行
// 1000ms时，1任务执行完毕，输出1，此时只剩下4任务在执行
// 1200ms时，4任务执行完毕，输出4
```

## 8. 手写 new 操作符实现
```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}
Person.prototype.say = function() {
  console.log(this.age);
};
let p1 = myNew(Person, "lihua", 18);
console.log(p1.name);
console.log(p1);
p1.say();
```

## 9. 手写 call apply bind 实现
```JS

function Person(name, age) {
  console.log(name); //'我是参数传进来的name'
  console.log(age); //'我是参数传进来的age'
  console.log(this); //构造函数this指向实例对象
}
// 构造函数原型的方法
Person.prototype.say = function() {
  console.log(123);
}
let obj = {
  objName: '我是obj传进来的name',
  objAge: '我是obj传进来的age'
}
// 普通函数
function normalFun(name, age) {
  console.log(name);   //'我是参数传进来的name'
  console.log(age);   //'我是参数传进来的age'
  console.log(this); //普通函数this指向绑定bind的第一个参数 也就是例子中的obj
  console.log(this.objName); //'我是obj传进来的name'
  console.log(this.objAge); //'我是obj传进来的age'
}

先测试作为构造函数调用
let bindFun = Person.myBind(obj, '我是参数传进来的name')
let a = new bindFun('我是参数传进来的age')
a.say() //123

再测试作为普通函数调用
let bindFun = normalFun.myBind(obj, '我是参数传进来的name')
 bindFun('我是参数传进来的age')
```

## 10. 深拷贝（考虑到复制 Symbol 类型）
```JS
var obj1 = {
a:1,
b:{a:2}
};
var obj2 = deepClone(obj1);
console.log(obj1);
```